# Propuesta Proyecto Final

Nuestro proyecto final, formado por Daniel Ruiz Figueroa y Rodrigo Cabello Hernández, consiste en crear una inteligencia artificial aplicándola en un videojuego del género de Tower Defense. El proyecto va a ser un Tower Defense en 3D, con una generación aleatoria del mundo en cada nivel, con niveles con distinta ambientación, con un arsenal de torres con diferentes funciones que el usuario podrá colocar en unos lugares correspondientes, es decir, en todas aquellas casillas que no sean el camino de los enemigos o no tengan decoración, cada torre con sus respectivas características,costes, stats, o utilidad, que se encargarán de defender la base de los enemigos. Los enemigos serán de distintos tipos tambié, cada uno con su daño,velocidad y aguante. El objetivo de estos será llegar al final del camino y el nuestro será aguantar el tiempo pedido en cada nivel antes de que los enemigos lleguen a nuestra torre y logren destruirla. Como solo somos dos integrantes en el proyecto, hemos decidido que ambos vamos a realizar todo juntos, hablando por discord y trabajando a la vez y con la utilización de "Live Share" de Visual Studio para poder programar los dos a la vez en los mismos scripts.

Nos vamos a encargar de que haya un menú principal, donde habrá tres niveles con distinta ambientación y tamaño de mapa, y tiempo que habrá que aguantar.
Nos vamos a encargar de hacer una generación de mundo aleatoria. Para ello se va a disponer el escenario en casillas, como en la práctica de los minotauros, y cada una será guardada en una lista.El mapa tiene dos variables que hacen referencia a la anchura y altura del mapa, y en cada nivel serán modiicadas para que vaya aumentando de tamaño con el pase de los niveles. La idea es al principio hacer únicamente un camino desde el spawn hasta la base, sin embargo, nos gustaría tener más de un camino posible, ya que vamos a hacer quelos eemigos sean capaces de elegir el camino en función tanto de la distancia a recorrer como del número de torres que se encuentren por el camino, pero primero lo haremos solo con un camino. A su vez, cada casilla tendría un valor correspondiente de paso, para que la IA de los enemigos pueda elegir el camino más rápido.
También nos vamos a encargar de la lógica de las torres, ya que cada torre podrá tener distintos comportamientos, habrá una torre de ataque, que disparará siempre al primer enemigo que entre en su radio de acción. También nos encontraremos una torre que nos proporcione dinero cada "X" tiempo para ayudar a construir más torres. Cada torre tendrá sus propias mejoras, las torres de ataque se podrán mejorar para que tengan más daño y más alcance, y la torre que proporciona dinero se podrá mejorar para que de dinero cada menos tiempo.
Por útilmo, vamos a realizar la generación de los enemigos que van a atacar nuestras bases, va a haber tres distintos, uno mujy rápido con poca vida, otro normal en ambos aspectos, y otro muy lento pero con mucha vida, cuando estos llegan a nuestra base, cada uno quita un daño distinto. Se van a mover a través del mapa generado automáticamente siguiendo el camino más corto, y eligiendolo en función de si es más costoso llegar por tiempo o por torres en el camino.
Pensamos que el contenido propuesto es bastante alcanzable para nosotros dos, a la vez que añadimos cosas nuevas. 

# Punto de partida

Nuestro proyecto utilizará assets de terceras personas que podamos encontrar en internet(modelos 3D, sonidos, ambientes, etc.). No obstante, todo lo relacionado al funcionamiento e implementación de la inteligencia artificial estará realizada por nosotros mismos, evitando usar recursos de terceras personas, aunque si que vamos a utilizar algunos de los scripts utilizados durante las prácticas de la asignatura, como pueden ser Node, Hilo, Graph, BinaryHeap,Vertex,etc. Creemos que necesitaremos estos scripts para poder utilizarlos tanto en la generación automática de mapas como en el movimiento del enemigo siguiendo un camino.

# ¿Cómo lo vamos a hacer?

Para la realización de la generación automática y aleatoria del terreno, aplicaremos un algoritmo que genera un camino a partir de unos prefabs para hacer referencia a las casillas, al inicio y final del camino, al camino y a la decoración.
Las torres, al tener diferentes tipos de funcionalidad, tendrán distintos scripts. 
Para la generación de enemigos, habrá tres prefabs de enemigos, cada uno con sus stats indicadas en un script "Enemigo". Los enemigos aparecerán con más frecuencia conforme vaya pasando el tiempo en cada nivel, hasta aparecer de manera masiva. Los enemigos mediante el algoritmo de Astar realizarán una búsqueda del camino óptimo para que sepan por cual camino es más probable llegar al final, ya sea por distancia o por torres en el camino.


# Solución

Lo primero de todo, decir que hemos creado un script "CameraOrbit" que nos permite mover la cámara a nuestro gusto, siempre con un margen, para estar siempre viendo al tablero, y podemos hacer zoom para acercarnos, esto nos da una gran visibilidad de todo el nivel y de lo que ocurre en cada momento, y mejor accesibilidad a casillas que pueden ser menos visibles ya sea por decoración o por la creación de nuestras torretas.

Para la generación de mapa, en el inicio del script *MapGenerator,* se realiza un bucle doble, creando una matriz de un tamaño determinado.
Y para la generación de decoración, después de la colocación de las casillas del mapa, existe una posibilidad de un 20% (de momento, quizás es mucho para ser estética) de que, entre los tipos de obstáculos que hayamos colocado en el prefab (Es una lista pública), coloque uno de estos en una casilla. En caso de que una casilla tenga decoración, no se podrá colocar una torre tanto de ataque como de dinero, esto hará que la dificultad del juego dependa en parte de la generación del mapa, ya que si se crean decoraciones cerca del camino, será más difícil crear torres con rango suficiente para atacar a los enemigos del camino, por eso la probabilidad de que se cree decoración es baja.
El algoritmo de generación de un camino se realiza en el mismo script. En primer lugar, se elige de manera aleatoria entre la parte superior del mapa o la parte izquierda del mapa para elegir el punto de inicio del que parten los enemigos, por lo que cuando se elija este punto, el punto donde deben llegar los enemigos será en el lado contrario. Cuando se elija desde qué lado se empieza, se elegirá una casilla aleatoria de un lado y del otro.
El algoritmo consiste en que primero girará a la izquierda o a la derecha, dependiendo de donde esté el fin de camino. Cuando se esté en el mismo nivel que la salida, se dibuja un camino de subida o de bajada, dependiendo si la salida está en la parte superior o inferior.
Para que los enemigos puedan transitar por el camino, a medida que se genera el camino, cuando se detecta que hay un cambio de dirección, se guarda esa casilla en una nueva lista, para que los enemigos sepan cuando tienen que cambiar de dirección. Los enemigos se destruyen al llegar a la casilla que se encuentra en el lado opuesto del comienzo del camino, la cual tiene un trigger que detecta que ha llegado un enemigo, lo destruye y resta la vida a la base. Encima de esta casilla colocamos otra torre distinta a modo de "Base", creada como la decoración.

Hemos usado el script spawner para generar enemigos. Al principio tiene un número máximo y mínimo de tiempo para crear un enemigo, los enemigos se crean siguiendo un número random entre el mínimo de creación y el máximo. Conforme va pasando la partida, estos dos números van disminuyendo, lo que hace que progresivamente tanto el tiempo mínimo como el máximo sean menores y se generen muchos más enemigos con el paso del tiempo.

Para los Enemigos utilizamos 2 scripts, que son el script "EnemyMovement" con el cual los enemigos son capaces de seguir el camino generado por el algoritmo AStar. Conforme se va moviendo el enemigo, y creando el mapa, se llaman a dos métodos, uno que se encarga de que el enemigo siga el camino de manera correcta, y otro que comprueba si hay algún camino mejor que el que estaba siguiendo el enemigo, en caso afirmativo, cambia el camino que deben de seguir los enemigos a este nuevo ( Esto en principio funciona pero como aun no nos funciona lo de los dos caminos no lo hemos probado).

Tenemos tres enemigos distintos, uno que tiene 3 vidas y se mueve a una velocidad 2.5, otro que tiene una vida y se mueve a una velocidad de 4, y otro que tiene 12 vidas que se mueve a una velocidad de 1. Los tres pueden aparecer en cualquier nivel de manera aleatoria, con la misma probabilidad, lo que hace que haya que gestiona bien el dinero y decidir si preferimos construir torres que nos den dinero para un futuro más sencillo, o construir torres de ataque al principio ya que nos pueden debilitar la torre fácilmente. Algo que creo que se me había olvidad comentar, es que nos dan 1 de dinero cada 0.4 segundos, sin embargo, no nos dan dinero al matar enemigos, solo con las torres de dinero y con el paso del tiempo.

Para el movimiento utilizamos los script “Graph”, “Vertex”, “Edge”, “BinaryHeap” y “EnemyMovement”.

- Vertex: Vértice del Grid, contiene una id, una lista de Vecinos y un vértice previo.
- Edge: conexión entre Vertex, guarda el coste de cada conexión entre Vértices.
- BinaryHeap: Montículo binario utilizado para guardar las aristas en orden de prioridad.
- Graph: en esta clase construimos un grafo utilizando los scripts mencionados anteriormente, en el método “GetPathAstar”, buscamos el camino óptimo entre dos vértices (Spawner, Objetivo), también tenemos en cuenta las torretas dispuestas en el mapa, ya que, estas afectarán al cálculo del camino óptimo para los enemigos. Recorremos una priorityQueue de aristas (BinaryHeap), de esta manera comprobamos los caminos y sus distintos costes, para ello recorremos la lista de torres, para que en el caso de que en el camino haya influencia de torres, el coste de dicho camino aumente. Dicho todo esto, el método GetPathAstar es capaz de obtener el camino óptimo teniendo en cuenta las torretas enemigas.

Para la gestión de las torres he creado distintos scripts, el primero es el "Selectable" que permite seleccionar una casilla para poder comprar, vender y mejorar las torretas. Se usa un raycast desde el punto de la cámara para saber a que GameObject apunta el cursor (De momento tenemos un problema que espero solucionar, y es que si pulsamos el botón para comprar una torreta, y debajo de la UI hay una casilla por que hemos hecho zoom, se crea en esta casilla y no en la que teníamos seleccionada). Además de todas las variables que permiten realizar el bucle de juego, tiene una variable para hacer referencia a la casilla seleccionada, y el TowerManager que tiene métodos que permiten crear, destruir, mejorar las torres.

Al igual que la gestión de enemigos, se utilizan varios scripts, el primero el script "Tower", que se encarga de disparar, en este script se encuentra mayor parte de la IA de las torres. Su propósito es seleccionar el enemigo óptimo dependiendo del comportamiento definido (al primero o al más fuerte). Además, posee el algoritmo de predicción del movimiento de los enemigos y el algoritmo para el cálculo del vector velocidad del proyectil. Por último, guarda los enemigos que estén dentro de su rango, para lo posible elección en caso de que sea una de las torres que ataca al más fuerte. Le sigue el script "Proyectil", que básicamente se encarga de controlar las colisiones y el daño de los proyectiles a los enemigos. El script "Enemigo" que permite identificar el tipo de enemigo y controlar sus vidas y por último el script "DrawRadius" que dibuja de forma visual el radio de alcance que tiene la torre en caso de que sea una torre de ataque.


Ahora vamos a hablar de la UI, para ella utilizamos el script de UIManager, este gestiona nuestar interfaz, la actualización de la misma, etc. En pantalla veremos en caso de tener una casilla seleccionada dos cosas, si esta vacía, es decir, no hemos colocado ningun torreta, nos aparecerá el botón de "Comprar" con el número de monedas que cuesta la torreta y con unas flechas para poder elegir el tipo de torreta que queremos comprar, el coste nos aparecerá en verde si tenemos suficiente dinero, o en rojo en caso contrario. Hablando del dinero, en la parte superior derecha tenemos la UI del dinero que tenemos, que se va actualizando cuando se reune más dinero. A su vez, aunque momentánemente, tenemos una variable de vida, esta está asi de momento, ya que queremos que sea una barra de vida y no un número, pero de momento así era más asquible hacerla. Continuando con lo anterior, en caso de tener una casilla seleccionada pero que esta si que tenga una torreta, nos aparecerán solo los botones para "Vender", "Mejorar Daño" o "Mejorar Alcance", en caso de que sean torretas de ataque o "Mejorar Dinero" en caso contrario. Vender las torretas nos devolverá parte del dinero que cuesta, pero claro la idea es colocarlas bien desde el inicio para no necesitar venderlas.


# Bibliografía y/o referentes

- *Diapositivas del Curso 2022-2023 de la asignatura de Inteligencia Artificial del tercer curso del grado de Desarrollo de Videojuegos impartida por Federico Peinado Gil.*
- *AI for Games, Third Edition Ian Millington.*
- *Unity Artificial Intelligence Cookbook, Third Edition 
- *Unity, Navegación y Búsqueda de caminos <https://docs.unity3d.com/es/2019.3/Manual/Navigation.html>*
- *Unity Artificial Intelligence Programming, Fourth Edition
- *Unity, Bolt Visual Scripting <https://docs.unity3d.com/bolt/1.4/manual/index.html>*
- *Opsive, Behavior Designer <https://opsive.com/assets/behavior-designer/>*


